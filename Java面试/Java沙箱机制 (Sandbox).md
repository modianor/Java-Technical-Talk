## Java沙箱机制 (Sandbox)

> ###### 出现的目的，是为了系统安全，防止不安全的Java代码访问计算机的系统资源（CPU、内存、文件系统、网络）。Java安全模型的核心就是Java沙箱 --- Sandbox



1. #### 什么是沙箱？

   沙箱是一个限制程序运行的环境。沙箱机制就是将Java代码限定在JVM特定的运行范围中，严格限制代码对本地系统资源的访问，通过这样的措施来保证对代码的有效隔离，放置对本地系统造成破坏。

2. #### Java中的沙箱是什么样的？

   在Java中将执行程序分成本地代码和远程代码两种，本地代码默认为可信任的，而远程代码则被看做不信任的。对于受信任的代码可以访问系统的一切本地资源。而对于不受信任的远程代码在早起的Java实现中，安全依赖于沙箱机制。如图所示JDK1.0安全模型

   ![沙箱](Java沙箱机制 (Sandbox).assets/20181022102129401.png)

   如此严格的沙箱安全机制虽然确保了安全，但是也给正常的功能拓展造成了阻碍。比如说当用户希望远程代码访问本地系统资源时，就无法实现。所以在jdk1.1之后，对沙箱安全机制进行了改进，增加了**安全策略**，允许用户指定代码对本地资源的访问权限，如图所示

   ![jdk1.1](Java沙箱机制 (Sandbox).assets/2018102210231938.png)
   
   在jdk1.2中，又对沙箱安全机制进行了改进，增加了**代码签名**。不论是本地代码还是远程代码，都会按照用户的安全访问策略设定，由类加载器加载道虚拟机中权限不同的运行空间，来实现代码差异化的运行权限控制。如图所示jdk1.2的沙箱模型
   
   ![å¨è¿éæå¥å¾çæè¿°](Java沙箱机制 (Sandbox).assets/20181022102746857-1583324528601.png)

当前最新的安全机制实现，引入了**域（Domain）**的概念。

虚拟机会把所有代码加载到不同的系统域和应用域中。**系统域**专门负责专门与关键资源进行加护，而各个**应用域**部分则通过系统域的部分代理来对各种需要的资源进行访问。虚拟机中不同的**受保护域（Protected Domain）**，对应不一样的权限（Permission）。存在于不同域中的类文件就具有了当前域的全部权限，如图所示

![img](Java沙箱机制 (Sandbox).assets/20181022103108566.png)

​	以上提到的都是基本的Java安全模型概念，在开发过程中有一些关于安全的复杂算法，其中最常用到的API就是doPrivilege。doPrivilege方法可以使一段受信任的代码获得更大的权限，甚至比调用他的应用程序还要多，可做到临时访问更多的资源。



#### 组成沙箱的基本组件

- 字节码校验器（bytecode verifier）：确保Java类文件遵循Java语言规范。这样可以帮助Java程序实现内存保护。但并不是所有的类文件都会经过字节码校验，比如核心类。

- 类装载器（classloader）：其中类装载器在三个方面对Java沙箱起作用

  - 防止恶意代码去干涉善意的代码
  - 守护了被信任的类库边界
  - 将代码归于保护域，确定了代码可以执行哪些操作

  虚拟机为不同的类加载器载入的类提供不同的命名空间，命名空间由一系列唯一的名称组成，每一个被装载的类将有一个名字，这个命名空间是由Java虚拟机为每个类装载器维护的，他们相互之间甚至不可见。

  

  类装载器采用的机制是**双亲委派模式**

  1. 从最内层JVM自带类加载器开始加载，外层恶意同名类得不到加载而无法正常使用。
  2. 由于严格通过包来区分了作用于，外层恶意代的类通过内置代码也无法获得权限访问到内层类，破坏代码就自然无法生效。

- 存取控制器（access controller）：存取控制器可以控制核心API对操作系统的存取权限，而这个控制的策略设定，可以由用户指定。
- 安全管理器（security manager）：java.security下的类和扩展包下的类，允许用户为自己的应用增加新的安全特性，包括
  - 安全提供者
  - 消息摘要
  - 数字签名
  - 加密
  - 鉴别